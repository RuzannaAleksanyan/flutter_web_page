<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flutter Web Page</title>

    <style>
        body {
            background:url(https://i.pinimg.com/564x/c9/50/92/c95092f9b83a25d2d50feec9e2708150.jpg)no-repeat center center/cover;
            backdrop-filter:blur(10px);
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            color: #333;
        }

        h1 {
            background-color: #3498db4f;
            backdrop-filter:blur(40px);
            color: #1d1d1d; /* Different color for h1 within the header */
            text-align: center;
            font-size: 50px;
        }


        main {
            max-width: 800px;
            margin: auto;
            padding:20px;
            background-color: #ffffff83;
            width: fit-content;
        }

        h2 {
            width: fit-content;
            padding: 5px 10px;
            background-color: #3498db4f;
            backdrop-filter:blur(40px);
            color: #1d1d1d;
        }
        pre {
          width: fit-content;
          background-color: #f9f9f960;
        }

        code {
            padding: 2px 5px;
            border-radius: 3px;
        }
        .new_Btn {
            display: flex;
            justify-content: space-between;
        }
        a {
            padding: 10px;
            font-size: 16px;
            background-color: #3498db;
            color: #fff;
            border: none;
            border-radius: 5px;
            text-decoration: none;
        }
    </style>
</head>
<body>

    <h1>Building a User Interface with Flutter Widgets</h1>


    <main>
        <section>
            <h2>1. Understanding Flutter widgets.</h2>
            <p>Flutter, Google's UI toolkit, revolves around the concept of widgets. In Flutter, everything is a widgetâ€”whether it's a button, a layout, or even the entire application itself. Understanding Flutter widgets is key to crafting expressive and dynamic user interfaces.</p>
            <p>At its core, a widget is a description of part of a user interface. Widgets can be as simple as a button or as complex as an entire screen. Flutter provides a wide variety of pre-built widgets, and developers can also create custom widgets to suit their application's needs.</p>
            <pre>
<code>
// Simple Text Widget
Text('Hello, Flutter!')
</code></pre>
            <p>Widgets in Flutter can be broadly categorized into two types: `StatelessWidget` and `StatefulWidget`. </p>
            <p>     **StatelessWidget**: Represents parts of the UI that don't change. For example, a piece of text or an icon.</p>
            <pre>
<code>
// Dart code here
class MyTextWidget extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
      return Text('I am a StatelessWidget');
    }
}
</code></pre>
            <p>     **StatefulWidget**: Represents parts of the UI that can change dynamically. For example, a counter that increments.</p>
            <pre>
<code>
// Dart code here
class MyCounterWidget extends StatefulWidget {
    @override
    _MyCounterWidgetState createState() => _MyCounterWidgetState();
}
  
class _MyCounterWidgetState extends State<MyCounterWidget> {
    int counter = 0;

    @override
    Widget build(BuildContext context) {
        return Column(
        children: [
            Text('Counter: $counter'),
            ElevatedButton(
            onPressed: () {
                setState(() {
                counter++;
                });
            },
            child: Text('Increment'),
            ),
        ],
        );
    }
}
</code></pre>
            <p>Flutter encourages widget composition, meaning that complex UIs are built by combining simple, reusable widgets. This promotes a modular and maintainable code structure.</p>
            <pre>
<code>
// Dart code here
// Widget Composition Example
class MyProfileWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        CircleAvatar(
          backgroundImage: AssetImage('profile_image.jpg'),
          radius: 50,
        ),
        SizedBox(height: 10),
        Text('John Doe'),
        Text('Software Developer'),
      ],
    );
  }
}
</code> </pre>
            <p>Flutter provides layout widgets like `Container`, `Row`, `Column`, and `Stack` to arrange and position child widgets on the screen.</p>
            <pre>
<code>
// Dart code here
// Container and Layout Widgets Example
Container(
  color: Colors.blue,
  padding: EdgeInsets.all(16),
  child: Row(
    mainAxisAlignment: MainAxisAlignment.center,
    children: [
      Icon(Icons.star),
      Text('Flutter Widgets'),
    ],
  ),
)
</code></pre>
            <p>Managing state is crucial in a Flutter app. The `provider` package is a popular choice for state management, allowing widgets to easily access and update shared state.</p>
            <pre>
<code>
// State Management with Provider Example
class CounterProvider extends ChangeNotifier {
    int _counter = 0;

    int get counter => _counter;

    void incrementCounter() {
    _counter++;
    notifyListeners();
    }
}

// Using the Provider
Consumer<CounterProvider>(
    builder: (context, counterProvider, child) {
    return Text('Counter: ${counterProvider.counter}');
    },
)
</code> </pre>
            <p>In Flutter, the widget tree represents the hierarchy of widgets in your application. Each widget has a parent-child relationship, forming a tree-like structure. Flutter efficiently updates and rebuilds only the necessary parts of the widget tree when there are changes.</p>
            <pre>
<code>
// Widget Tree Example
class MyWidgetTree extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
    return Column(
        children: [
        Text('Parent Widget'),
        MyChildWidget(),
        ],
    );
    }
}

class MyChildWidget extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
    return Text('Child Widget');
    }
}
</code> </pre>
            <p>Understanding Flutter widgets is like mastering the magic behind Flutter's flexibility and expressiveness. As you become fluent in widget composition, leverage state management, and navigate the widget tree, you'll find yourself seamlessly crafting captivating and responsive user interfaces. Flutter's widget-centric approach empowers developers to create not just applications, but interactive and visually stunning experiences.</p>
        </section>

        <section>
            <h2>2. Layouts and navigation in Flutter</h2>
            <p>Flutter empowers developers to create beautiful and responsive user interfaces through flexible layouts and seamless navigation. Let's explore how to structure layouts and implement navigation in Flutter to build engaging mobile applications.</p>
            <p>Flutter offers a variety of layout widgets to structure UI components. Common ones include:</p>
            <p>     **Container**: A box model for customization.</p>
            <p>     **Row** and **Column**: For horizontal and vertical arrangements of widgets.</p>
            <p>     **Stack**: Overlapping widgets.</p>
            <p>     **ListView** and **GridView**: Scrolling lists and grids.</p>
            <pre>
<code>
// Example of Basic Layout Widgets
Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: [
    Text('Hello, Flutter!'),
    Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: [
        Icon(Icons.star),
        Icon(Icons.star),
        Icon(Icons.star),
        ],
    ),
    ],
)
</code></pre>
            <p>Flutter uses a routing system for navigation. Define routes and use the `Navigator` to navigate between different screens.</p>
            <pre>
<code>
// Example of Navigation with Routes
MaterialApp(
    initialRoute: '/',
    routes: {
    '/': (context) => HomeScreen(),
    '/details': (context) => DetailsScreen(),
    },
)
</code> </pre>
            <p>Use `Navigator.push` to move from one screen to another. Provide the route name or a widget as the new screen.</p>
            <pre>
<code>
// Navigating to a New Screen Example
ElevatedButton(
    onPressed: () {
    Navigator.pushNamed(context, '/details');
    },
    child: Text('Go to Details'),
)
</code> </pre>
            <p>To send data between screens, include it in the `Navigator.push` method.</p>
            <pre>
<code>
// Passing Data Between Screens Example
ElevatedButton(
    onPressed: () {
    Navigator.pushNamed(
        context,
        '/details',
        arguments: {'title': 'Flutter Details'},
    );
    },
    child: Text('Go to Details'),
)
</code> </pre>
            <p>Retrieve the passed data on the new screen using `ModalRoute.of(context).settings.arguments`.</p>
            <pre>
<code>
// Retrieving Data on the New Screen Example
class DetailsScreen extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
    final Map<String, dynamic> data =
        ModalRoute.of(context)!.settings.arguments as Map<String, dynamic>;

    return Scaffold(
        appBar: AppBar(title: Text(data['title'])),
        body: Center(child: Text('Details Screen')),
    );
    }
}
</code> </pre>
            <p>Implement a drawer for navigation within the app, providing easy access to different sections.</p>
            <pre>
<code>
// Drawer for App Navigation Example
Scaffold(
    appBar: AppBar(title: Text('My App')),
    drawer: Drawer(
    child: ListView(
        padding: EdgeInsets.zero,
        children: [
        DrawerHeader(
            decoration: BoxDecoration(
            color: Colors.blue,
            ),
            child: Text('App Navigation'),
        ),
        ListTile(
            title: Text('Home'),
            onTap: () {
            Navigator.pop(context); // Close the drawer
            Navigator.pushNamed(context, '/');
            },
        ),
        ListTile(
            title: Text('Details'),
            onTap: () {
            Navigator.pop(context);
            Navigator.pushNamed(context, '/details');
            },
        ),
        ],
    ),
    ),
    body: Center(child: Text('Home Screen')),
)
</code> </pre>
            <p>Mastering layouts and navigation in Flutter is the key to delivering a delightful user experience. By combining flexible layout widgets, smooth navigation between screens, and thoughtful responsiveness, Flutter enables developers to build mobile applications that not only look great but also provide a seamless and intuitive journey for users. Explore the vast Flutter widget library to unleash your creativity and craft engaging user interfaces.</p>
        </section>

        <section>
            <h2>3. Styling and theming in Flutter.</h2>
            <p>Flutter provides powerful tools for styling and theming, allowing developers to create visually appealing and consistent user interfaces. Let's dive into the world of styling and theming in Flutter to enhance the look and feel of your mobile applications.</p>
            <p>Styling individual widgets in Flutter involves applying styles using the `style` property. The `TextStyle` class is commonly used for text styling.</p>
            <pre>
<code>
// Styling Text Widget Example
Text(
    'Styled Text',
    style: TextStyle(
    color: Colors.blue,
    fontSize: 18.0,
    fontWeight: FontWeight.bold,
    ),
)
</code> </pre>
            <p>Flutter themes encapsulate a set of visual properties that can be applied uniformly throughout an application. Themes are defined using the `ThemeData` class.</p>
            <pre>
<code>
// Theme Example
MaterialApp(
    theme: ThemeData(
    primaryColor: Colors.blue,
    accentColor: Colors.green,
    fontFamily: 'Roboto',
    ),
    home: MyHomePage(),
)
</code> </pre>
            <p>Developers can create custom themes to match the design requirements of their applications, providing a consistent and branded appearance.</p>
            <pre>
<code>
// Custom Theme Example
final ThemeData myTheme = ThemeData(
    primaryColor: Colors.purple,
    accentColor: Colors.orange,
    fontFamily: 'Montserrat',
);

// Applying Custom Theme
MaterialApp(
    theme: myTheme,
    home: MyHomePage(),
)
</code> </pre>
            <p>Flutter supports dynamic theming, allowing users to switch between light and dark modes or other themes easily. This is achieved by dynamically updating the theme based on user preferences.</p>
            <pre>
<code>
// Dynamic Theming Example
bool isDarkModeEnabled = getDarkModePreference();

MaterialApp(
    theme: isDarkModeEnabled ? darkTheme : lightTheme,
    home: MyHomePage(),
)
</code> </pre>
            <p>Widgets can be individually themed, providing granular control over the visual aspects of each component. This is particularly useful for customizing specific elements within a broader theme.</p>
            <pre>
<code>
// Theming Widget Example
Container(
    decoration: BoxDecoration(
    color: Theme.of(context).accentColor,
    borderRadius: BorderRadius.circular(10.0),
    ),
    child: Text('Themed Container'),
)
</code> </pre>
            <p>Buttons in Flutter can be styled using the `ElevatedButton` or `TextButton` widgets, with customization options for color, shape, and more.</p>
            <pre>
<code>
// Styling Button Example
ElevatedButton(
    onPressed: () {
    // Button Pressed
    },
    style: ElevatedButton.styleFrom(
    primary: Colors.blue,
    shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10.0),
    ),
    ),
    child: Text('Press Me'),
)
</code> </pre>
            <p>Flutter also supports the Cupertino design language used in iOS applications. The `CupertinoTheme` widget and related components can be used to achieve an iOS-like look and feel.</p>
            <pre>
<code>
// Cupertino Style Example
CupertinoTheme(
    data: CupertinoThemeData(
    primaryColor: Colors.blue,
    scaffoldBackgroundColor: Colors.white,
    ),
    child: CupertinoPageScaffold(
    navigationBar: CupertinoNavigationBar(
        middle: Text('Cupertino Style'),
    ),
    child: Center(
        child: Text('Hello, iOS!'),
    ),
    ),
)
</code> </pre>
            <p>Styling and theming in Flutter go hand in hand, offering a plethora of options to create visually stunning and consistent interfaces. Whether applying styles to individual widgets, defining themes for the entire application, or allowing dynamic theming, Flutter empowers developers to craft mobile apps that not only function flawlessly but also delight users with a polished and aesthetically pleasing design. Explore the rich palette of styling and theming options in Flutter to unleash your creativity and bring your app to life with style.</p>
        </section>

        <section>
            <h2>4. Handling user input and gestures.</h2>
            <p>In Flutter, providing a responsive and interactive user experience is fundamental. Let's explore the tools and techniques for handling user input and gestures, allowing your Flutter applications to seamlessly respond to user interactions.</p>
            <p>Use the `GestureDetector` widget to capture taps and clicks on specific widgets. The `onTap` callback allows you to respond to user interactions.</p>
            <pre>
<code>
// Handling Taps Example
GestureDetector(
    onTap: () {
    print('Container tapped!');
    },
    child: Container(
    width: 200.0,
    height: 100.0,
    color: Colors.blue,
    child: Center(
        child: Text('Tap me!'),
    ),
    ),
)
</code> </pre>
            <p>For capturing text input, use the `TextField` widget. The `onChanged` callback allows you to respond dynamically to the user's input.</p>
            <pre>
<code>
// Handling Text Input Example
TextField(
    onChanged: (text) {
    print('User typed: $text');
    },
    decoration: InputDecoration(labelText: 'Type something...'),
)
</code> </pre>
            <p>Flutter includes gesture recognizers for detecting various gestures like taps, double taps, long presses, and more. These can be configured directly on the `GestureDetector` widget.</p>
            <pre>
<code>
// Gesture Recognizer Example
GestureDetector(
    onDoubleTap: () {
    print('Double tap!');
    },
    onLongPress: () {
    print('Long press!');
    },
    child: Container(
    width: 100.0,
    height: 100.0,
    color: Colors.green,
    ),
)
</code> </pre>
            <p>Swiping and dragging gestures are common in mobile apps. Flutter provides widgets like `Dismissible` and `Draggable` for handling these gestures seamlessly.</p>
            <pre>
<code>
// Handling Swipes and Drags Example
Dismissible(
    key: Key('itemKey'),
    onDismissed: (direction) {
    print('Item dismissed!');
    },
    background: Container(color: Colors.red),
    child: ListTile(
    title: Text('Swipe me!'),
    ),
)
</code></pre>
            <p>Integrate animations with gestures to create a dynamic user interface. The `AnimatedBuilder` widget can be used to animate UI elements based on gestures.</p>
            <pre>
<code>
// Gesture Animation Example
GestureDetector(
    onPanUpdate: (details) {
    // Update animation based on pan gestures
    },
    child: AnimatedBuilder(
    animation: animationController,
    builder: (context, child) {
        return Transform.rotate(
        angle: animationController.value * 2 * pi,
        child: child,
        );
    },
    child: Icon(Icons.rotate_left),
    ),
)
</code> </pre>
            <p>Handling user input and gestures in Flutter is pivotal for creating engaging and intuitive mobile applications. By integrating gesture detectors, recognizing various user actions, and responding dynamically to input, Flutter empowers developers to craft interactive and responsive UIs. Embrace the versatility of gesture handling in Flutter to elevate your app's user experience and make it a joy for users to interact with.</p>
        </section>

        <section>
            <h2>5. Building responsive user interfaces.</h2>
            <p>Creating responsive user interfaces is crucial for providing a seamless experience across various devices and screen sizes. Flutter offers powerful tools and techniques to build responsive layouts, ensuring your mobile applications adapt gracefully to different screen dimensions. Let's explore how to make your Flutter UIs responsive.</p>
            <p>Flutter's `MediaQuery` class provides information about the current device's screen size and orientation. Use it to make layout decisions based on the available space.</p>
            <pre>
<code>
// MediaQuery Example
Container(
    width: MediaQuery.of(context).size.width * 0.8, // 80% of screen width
    height: MediaQuery.of(context).size.height * 0.5, // 50% of screen height
    child: Text('Responsive Container'),
)
</code>
            </pre>
            <p>The `LayoutBuilder` widget is handy for creating responsive layouts that adapt to the constraints imposed by the parent widget.</p>
            <pre>
<code>
// LayoutBuilder Example
LayoutBuilder(
    builder: (context, constraints) {
    if (constraints.maxWidth > 600) {
        return DesktopLayout();
    } else {
        return MobileLayout();
    }
    },
)
</code></pre>
            <p>Use `Flexible` and `Expanded` widgets to create layouts that adjust dynamically to available space. These widgets are especially useful in `Row` and `Column` structures.</p>
            <pre>
<code>
// Flexible and Expanded Example
Row(
    children: [
    Flexible(
        flex: 1,
        child: Container(color: Colors.red),
    ),
    Expanded(
        flex: 2,
        child: Container(color: Colors.green),
    ),
    ],
)
</code> </pre>
            <p>Flutter's `GridView` and `ListView` are perfect for displaying lists or grids of items that can scroll. They automatically adjust to the available screen space.</p>
            <pre>
<code>
// GridView Example
GridView.builder(
    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
    crossAxisCount: MediaQuery.of(context).size.width ~/ 200, // Adjust based on screen width
    ),
    itemBuilder: (context, index) {
    return GridItem();
    },
)
</code>  </pre>
            <p>Maintain aspect ratios for widgets using the `AspectRatio` widget, ensuring that components scale proportionally on different screens.</p>
            <pre>
<code>
// AspectRatio Example
AspectRatio(
    aspectRatio: 16 / 9, // Maintain a 16:9 aspect ratio
    child: Container(
    color: Colors.blue,
    child: Center(child: Text('Proportional Layout')),
    ),
)
</code> </pre>
            <p>The `AutoSizeText` package allows text to automatically adjust its size based on available space, ensuring readability on various devices.</p>
            <pre>
<code>
// AutoSizeText Example
AutoSizeText(
    'Responsive Text',
    style: TextStyle(fontSize: 20),
    maxLines: 1,
)
</code> </pre>
            <p>Flutter empowers developers to build responsive user interfaces that shine on devices of all shapes and sizes. Whether leveraging `MediaQuery` for screen information, employing `LayoutBuilder` for dynamic layouts, or using flexible widgets and responsive font solutions, Flutter provides a rich toolkit for crafting adaptive and visually pleasing mobile applications. Embrace the flexibility and responsiveness of Flutter to ensure your app looks great on every device it touches.</p>
        </section>
        <div class="new_Btn">
            <a href="page1.html">PREV</a>
            <a href="page3.html">NEXT</a>
        </div>
    </main>
</body>
</html>
